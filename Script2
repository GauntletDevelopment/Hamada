####################################################################################################

# IMPORT MODULES

####################################################################################################

import time
import math
import json
import keyboard
import os
import requests
import subprocess
import sys
from io import BytesIO

import pyautogui
import pyperclip
import autoit
import tkinter
from tkinter import *
import customtkinter
from PIL import Image, ImageFont, ImageTk

####################################################################################################

# CHECK IF PYTHON PACKAGES ARE INSTALLED

####################################################################################################


# Function to install a package using pip
def install(package):
    subprocess.check_call([sys.executable, "-m", "pip", "install", package])

# List of required libraries
required_libraries = [
    'pyautogui',
    'pyperclip',
    'autoit',
    'PIL',  # Pillow includes Image, ImageFont, and ImageTk
    'customtkinter'
]

# Check and install missing libraries
for lib in required_libraries:
    try:
        __import__(lib)  # Try importing the library
    except ImportError:
        print(f"{lib} not found, installing...")
        install(lib)

# Check for tkinter separately, as it's part of the standard library but may not be installed on all systems
try:
    import tkinter
    from tkinter import *
except ImportError:
    print("tkinter not found, installing...")
    install('tkinter')  # tkinter might need to be installed separately on Linux in some cases

print("All libraries are installed. You can now use them.")



####################################################################################################

# DEFINE THE PIXELWARE DIRECTORY

####################################################################################################


# Get the directory where the current script (main.py) is located
currentDirectory = os.path.dirname(os.path.abspath(__file__))
# If you want to go up one directory to reference the 'PixelWare' folder
parentDirectory = os.path.dirname(currentDirectory)

workspace = parentDirectory  # Path to the main folder (PixelWare)
settingsPath = os.path.join(workspace, "settings.json")




####################################################################################################

# FUNCTIONS

####################################################################################################

# Function that resizes an image and returns the new cropped image object
import os
import requests
from PIL import Image
from io import BytesIO

def resizeImage(imageName):
    folder = os.path.join(workspace, "images") # Folder containing the images
    extensions = [".png", ".jpg"] # Try both .png and .jpg extensions for local files
    imagePath = None
    img = None

    # If imageName starts with "http" or "https", treat it as a URL
    if imageName.startswith("http://") or imageName.startswith("https://"):
        # Download the image from the URL
        try:
            response = requests.get(imageName)
            response.raise_for_status()  # Check if the request was successful
            img = Image.open(BytesIO(response.content))  # Open image from byte data
        except requests.exceptions.RequestException as e:
            raise FileNotFoundError(f"Failed to download image from URL: {e}")
    else:
        # Otherwise, treat it as a local image
        for ext in extensions:
            potentialPath = os.path.join(folder, imageName + ext)
            if os.path.exists(potentialPath):
                imagePath = potentialPath
                break

        if imagePath == None:
            print("Image path not found")
            # raise FileNotFoundError(f"Image '{imageName}' not found as .png or .jpg in folder '{folder}'.")
        else:
            img = Image.open(imagePath)

    # Get the size of the image (width, height)

    if img != None:
        width, height = img.size
                # Calculate the dimensions for the square crop (use the smaller dimension)
        if width > height:
            # Crop the sides of the image (cut left and right)
            left = (width - height) // 2
            top = 0
            right = left + height
            bottom = height
        else:
            # Crop the top and bottom of the image (cut top and bottom)
            top = (height - width) // 2
            left = 0
            right = width
            bottom = top + width
        croppedImage = img.crop((left, top, right, bottom)) # Crop the image (this will remove edges and center it)
        resizedImage = croppedImage.resize((32, 32)) # Resize the cropped square image to 32x32 pixels
        resizedImage = resizedImage.convert("RGB") # Convert the image to RGB (in case it's RGBA or grayscale)
        return resizedImage # Return the resized image
    else:
        return None





####################################################################################################

# MAIN SCRIPT

####################################################################################################

# Retrieve the settings from settings.json
with open(settingsPath,'r', encoding="utf8", errors='ignore') as f:
    s = json.load(f)


speed = math.floor(10 / s['speed'])
canvasX1 = s['canvasX1']
canvasY1 = s['canvasY1']
canvasX2 = s['canvasX2']
canvasY2 = s['canvasY2']
run = s['run']
keySkip = s['keySkip']

def generate(entry):

    time.sleep(2)
    global canvasX1,canvasY1,canvasX2,canvasY2

    image = resizeImage(entry)
    stepx = math.floor((canvasX2-canvasX1)/31)
    stepy = math.floor((canvasY2-canvasY1)/31)

    if (run == 1):
        autoit.mouse_move(603, 833, speed)
        autoit.mouse_click()
        dy1 = canvasY1
        for y in range(0,32,1):
            t0 = time.time()
            dx1 = canvasX1
            for x in range(0,32,1):
                if keyboard.is_pressed(keySkip):
                    break
                color = image.getpixel((x, y))
                hexc = '%02x%02x%02x' % color
                pyperclip.copy(hexc)
                autoit.mouse_move(603, 833, speed)
                autoit.mouse_click()
                autoit.mouse_move(602, 736, speed)
                autoit.mouse_click()
                clipboard = pyperclip.paste()
                pyautogui.write(clipboard)
                autoit.mouse_move(838, 467, speed)
                autoit.mouse_click()
                autoit.mouse_move(dx1, dy1, speed)
                autoit.mouse_click()
                dx1 = dx1 + stepx
                if (x == 16 and y == 0):
                    t1 = time.time()
                    minutes = math.floor(128*(t1-t0)/60)
                    seconds = math.floor(128*(t1-t0)) - 60*minutes
                    print("Estimated time until finish: " + str(minutes) + " minutes, " + str(seconds) + " seconds")
            dy1 = dy1 + stepy
            autoit.mouse_move(dx1, dy1, speed)

    if (run == 2):
        print("X: " + str(pyautogui.position().x) + ", Y: " + str(pyautogui.position().y))

    if (run == 3):
        dx1 = canvasX1
        for x in range(0, 32, 1):
            time.sleep(0.1)
            autoit.mouse_move(dx1, canvasY1, 0)
            dx1 = dx1 + stepx
        time.sleep(1)
        autoit.mouse_move(canvasX1,canvasY1)
        dy1 = canvasY1
        for y in range(0, 32, 1):
            time.sleep(0.1)
            autoit.mouse_move(canvasX1, dy1, 0)
            dy1 = dy1 + stepy




####################################################################################################

# GRAPHICAL USER INTERFACE

####################################################################################################

defaultImagePath = Image.open(os.path.join(workspace, "icons", "default.png"))
defaultImage = customtkinter.CTkImage(light_image=defaultImagePath, size=(200, 200))

# Function to update the displayed image in Tkinter
def displayImageEntry():
    resizedImage = resizeImage(entry.get())  # Resize to 100x100 pixels
        
    if resizedImage != None:
        # Convert the PIL image to customtkinter compatible format
        ctkImage = customtkinter.CTkImage(light_image=resizedImage, size=(200, 200))
        imageLabel.configure(image=ctkImage)
        imageLabel.image = ctkImage  # Keep a reference to the image to avoid garbage collection
    else:
        imageLabel.configure(image=defaultImage)

def centerWindow():
    # Get the screen width and height
    screen_width = root.winfo_screenwidth()
    screen_height = root.winfo_screenheight()

    # Get the current window width and height
    window_width = root.winfo_width()
    window_height = root.winfo_height()

    # Calculate the position to center the window
    position_top = (screen_height // 2) - (window_height // 2)
    position_left = (screen_width // 2) - (window_width // 2)

    # Position the window in the center of the screen
    root.geometry(f'{window_width}x{window_height}+{position_left}+{position_top}')


def generateImage():
    print("Generating...")
    generate(str(entry.get()))

####################################################################################################

import ctypes
myappid = u'mycompany.myproduct.subproduct.version'
ctypes.windll.shell32.SetCurrentProcessExplicitAppUserModelID(myappid)
customtkinter.set_appearance_mode("dark")
customtkinter.set_default_color_theme("dark-blue")

root = customtkinter.CTk()
root.title("PixelWare")
root.iconbitmap(os.path.join(workspace, "icons", "beasticon.ico"))
root.geometry("600x300")
root.after(100, centerWindow)

label = customtkinter.CTkLabel(root, font=("Consolas", 11), text="PixelWare v1.3.0")
label.place(relx=0.02, rely=0.01, anchor="nw")

label2 = customtkinter.CTkLabel(root, font=("Consolas", 14), text="Name or URL of your image:")
label2.place(relx=0.1, rely=0.35, anchor="w")

entry = customtkinter.CTkEntry(root, font=("Consolas", 14), width=200, height=10)  # Text box for user input
entry.place(relx=0.1, rely=0.45, anchor="w")
entry.bind("<KeyRelease>", lambda event: displayImageEntry())

button1 = customtkinter.CTkButton(root, font=("Consolas",14), text="Generate", width=100, height=35, command=lambda: generateImage())
button1.place(relx=0.1, rely=0.65, anchor="w")

imageLabel = customtkinter.CTkLabel(root, image=defaultImage, text = "")
imageLabel.place(relx=0.6, rely=0.5, anchor="w")  # Position in the center of the window

root.mainloop()
